---
title: "R Notebook"
output: html_notebook
---

The purpose of this R notebook is to provide a hypothetical pipeline outlinging how sample matching will work for the startup company Rebilance.

In the R notebook, the steps outlining the contruction of a sPLS-DA model have been outlined. The resultant model will be used to do the following things in this notebook:

```         
  1. Associate the sample as either a "healthy" or "unhealthy" individual. 
  2. Provide a score for how "unhealthy" they are
  3. Identify which types of Genus they lack, compared to the sample "healthy" population. 
  4. Propose a list of potential supplementation strategy to bring the individual closer to the "healthy" sample group. 
  
  
```

We will begin by reading in our model, as saved in the "Gmodel.Rmd" notebook.

```{r}
# We can load in our model
splsda <- readRDS("splsda_model.rds")

# And also our test set of HFM individuals. 

testing_set <- readRDS("testing_set.rds")

# Initialize a list to store the dataframes
df_list <- list()

# Split the testing_set into four dataframes
for (i in 1:nrow(testing_set)) {
  df_list[[i]] <- testing_set[i, ]
}

df1 <- df_list[[1]]
df2 <- df_list[[2]]
df3 <- df_list[[3]]
df2o <- df2
```

```{r}
# Remove the first two columns from df1
df1 <- df1[, -c(1:2)]
df2 <- df2[, -c(1:2)]
df3 <- df3[, -c(1:2)]



```

```{r}
# Define model variable

dfm <- df1

new_sample_scores <- predict(splsda, newdata = dfm, type = "scores")

```

```{r}
# Assuming df1 is a dataframe with a single row (sample)
# new_sample_scores <- predict(splsda, newdata = df1, type = "scores")  # Uncomment this line if splsda and df1 are defined

# Extract the predicted score for the first component and first class
predicted_score <- new_sample_scores$predict[, , 1]

# Print the predicted score
print(predicted_score)
```

```{r}
# Define a test variable 

if(predicted_score["1"] > 0.5){
  # If the condition is met, assign dfm to dft
  dft <- dfm
}
```

```{r}
# Get the loadings of the genera in the first component
loadings <- splsda$loadings$X[, "comp1"]

# Sort the loadings in decreasing order
sorted_loadings <- sort(loadings, decreasing = TRUE)
```

```{r}
# Filter the loadings to keep only the positive ones (associated with 'healthy')
healthy_loadings <- sorted_loadings[sorted_loadings < 0]

# Get the names of the top 15 contributing genera for healthy individuals
top_healthy_genera <- names(healthy_loadings)[1:30]

# Print the top 60 genera
print(top_healthy_genera)

```

```{r}
# Assuming original_data is a dataframe where the rows are individuals, 
# the columns (except the last one) are genera, and the last column is the health status
df_long <- readRDS("joined_data")
#df_long <- df_long[, -1]

```

```{r}
# Step 1: Find the top 30 positive contributing genera for healthy users
get_top_healthy_genera <- function(n_genera = 30){
    # Get the loadings of the genera in the first component
    loadings <- splsda$loadings$X[, "comp1"]

    # Sort the loadings in decreasing order
    sorted_loadings <- sort(loadings, decreasing = TRUE)

    # Filter the loadings to keep only the negative ones (associated with 'healthy')
    healthy_loadings <- sorted_loadings[sorted_loadings < 0]

    # Get the names of the top contributing genera for healthy individuals
    top_healthy_genera <- names(healthy_loadings)[1:n_genera]
    
    return(top_healthy_genera)
}
top_healthy_genera <- get_top_healthy_genera()

# Step 2: Filter out the df_long dataframe to include only these genera for healthy and unhealthy users
df_long_filtered <- df_long[, c("Group", top_healthy_genera)]

# Step 3: Calculate the average abundances of each of these genera in the df_long dataframe
average_abundance <- colMeans(df_long_filtered[df_long_filtered$Group == 0, -1])

# Step 4: Perform steps 2 and 3 on the dft dataframe
# The dft dataframe contains only genera columns (and no 'Group' column)
dft_filtered <- dft[, top_healthy_genera]
average_abundance_dft <- colMeans(dft_filtered)

# Step 5: If the average abundance for any of these genera is higher in the average healthy abundances than they are in the dft dataframe, print them out.
deficient_genera <- names(average_abundance)[average_abundance > average_abundance_dft]

# Calculate the difference in abundance for deficient genera
abundance_difference <- average_abundance[deficient_genera] - average_abundance_dft[deficient_genera]

# Print deficient genera and their difference in abundance
print(data.frame(Genera = deficient_genera, Abundance_Difference = abundance_difference))

```

Customer abundance divided by the mean abundance (healthy).











